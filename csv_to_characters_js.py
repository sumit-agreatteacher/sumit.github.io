#!/usr/bin/env python3
import argparse, csv, json, re
from typing import Set, List

NUMBER_RE = re.compile(r"[+-]?(?:\d+(?:\.\d*)?|\.\d+)$")

def coerce_value(key: str, val: str, boolean_keys: Set[str]):
    if val is None:
        return None
    s = str(val).strip()
    if s == "":
        if key == "location":
            return None
        return ""

    if key in boolean_keys:
        lower = s.lower()
        if lower in ("true", "false", "yes", "no", "1", "0"):
            return lower in ("true", "yes", "1")

    if NUMBER_RE.fullmatch(s):
        try:
            f = float(s)
            return int(f) if f.is_integer() else f
        except Exception:
            pass

    lower = s.lower()
    if lower in ("true", "false", "yes", "no"):
        return lower in ("true", "yes")

    return s

def to_js_value(v):
    if v is None:
        return "null"
    if isinstance(v, bool):
        return "true" if v else "false"
    if isinstance(v, (int, float)):
        return json.dumps(v, ensure_ascii=False)
    # string
    return json.dumps(str(v), ensure_ascii=False)

def row_to_js_object(row, field_order: List[str]):
    keys = list(field_order) + [k for k in row.keys() if k not in field_order]
    parts = []
    for k in keys:
        if k not in row:
            continue
        v = row[k]
        parts.append(f"{k}: {to_js_value(v)}")
    return "{\n    " + ",\n    ".join(parts) + "\n  }"

def emit_single_array(rows, header, out_fp):
    out_fp.write("// Generated by csv_to_characters_js_patched.py (single-array mode)\n")
    out_fp.write("const characters = [\n")
    for i, row in enumerate(rows):
        js_obj = row_to_js_object(row, header)
        out_fp.write("  " + js_obj)
        if i < len(rows) - 1:
            out_fp.write(",")
        out_fp.write("\n")
    out_fp.write("];\n")
    out_fp.write("\nexport { characters };\n")

def emit_grouped(rows, header, out_fp):
    pis, phds, postdocs, copis = [], [], [], []
    for row in rows:
        t = str(row.get("type", "")).strip().lower()
        if t == "phd":
            phds.append(row)
        elif t == "postdoc":
            postdocs.append(row)
        elif t == "copi":
            copis.append(row)
        else:
            pis.append(row)

    out_fp.write("// Generated by csv_to_characters_js_patched.py (grouped-by-type mode)\n")

    def write_array(name, arr):
        out_fp.write(f"const {name} = [\n")
        for i, r in enumerate(arr):
            out_fp.write("  " + row_to_js_object(r, header))
            if i < len(arr) - 1:
                out_fp.write(",")
            out_fp.write("\n")
        out_fp.write("];\n\n")

    write_array("characters", pis)
    write_array("phdCandidates", phds)
    write_array("postdocCandidates", postdocs)
    write_array("coPICandidates", copis)
    out_fp.write("export { characters, phdCandidates, postdocCandidates, coPICandidates };\n")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--csv", default="characters_unified.csv")
    ap.add_argument("--out", default="characters.js")
    ap.add_argument("--group-by-type", action="store_true")
    ap.add_argument("--boolean-keys", default="hired")
    args = ap.parse_args()

    boolean_keys = set([k.strip() for k in args.boolean_keys.split(",") if k.strip()])

    with open(args.csv, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        header = reader.fieldnames or []
        rows = [{k: coerce_value(k, v, boolean_keys) for k, v in row.items()} for row in reader]

    with open(args.out, "w", encoding="utf-8", newline="\n") as out_fp:
        if args.group_by_type:
            emit_grouped(rows, header, out_fp)
        else:
            emit_single_array(rows, header, out_fp)

    print(f"Wrote {args.out} with {len(rows)} characters; boolean keys: {sorted(boolean_keys)}")

if __name__ == "__main__":
    main()
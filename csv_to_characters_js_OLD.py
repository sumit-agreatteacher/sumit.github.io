#!/usr/bin/env python3
import argparse, csv, json, re
from typing import Set, List

NUMBER_RE = re.compile(r"[+-]?(?:\d+(?:\.\d*)?|\.\d+)$")

def coerce_value(key: str, val: str, boolean_keys: Set[str]):
    if val is None:
        return None
    s = str(val).strip()
    if s == "":
        if key == "location":
            return None
        return ""

    if key in boolean_keys:
        lower = s.lower()
        if lower in ("true", "false", "yes", "no", "1", "0"):
            return lower in ("true", "yes", "1")

    if NUMBER_RE.fullmatch(s):
        try:
            f = float(s)
            return int(f) if f.is_integer() else f
        except Exception:
            pass

    lower = s.lower()
    if lower in ("true", "false", "yes", "no"):
        return lower in ("true", "yes")

    return s

def to_js_value(v):
    if v is None:
        return "null"
    if isinstance(v, bool):
        return "true" if v else "false"
    if isinstance(v, (int, float)):
        return json.dumps(v, ensure_ascii=False)
    return json.dumps(str(v), ensure_ascii=False)

def row_to_js_object(row, field_order: List[str]):
    keys = list(field_order) + [k for k in row.keys() if k not in field_order]
    parts = []
    for k in keys:
        if k not in row:
            continue
        v = row[k]
        parts.append(f"{k}: {to_js_value(v)}")
    return "{\n    " + ",\n    ".join(parts) + "\n  }"

def emit_single_array(rows, header, out_fp, esm: bool, derive_globals: bool):
    out_fp.write("// Generated by csv_to_characters_js.py (single-array mode)\n")
    out_fp.write("const characters = [\n")
    for i, row in enumerate(rows):
        js_obj = row_to_js_object(row, header)
        out_fp.write("  " + js_obj)
        if i < len(rows) - 1:
            out_fp.write(",")
        out_fp.write("\n")
    out_fp.write("];\n")

    if derive_globals:
        out_fp.write('\n// Derived candidate arrays for legacy global code:\nconst phdCandidates     = characters.filter(c => (String(c.type || "").toLowerCase()) === "phd" && !c.hired);\nconst postdocCandidates = characters.filter(c => (String(c.type || "").toLowerCase()) === "postdoc" && !c.hired);\nconst coPICandidates    = characters.filter(c => (String(c.type || "").toLowerCase()) === "copi" && !c.hired);\n')

    if esm:
        if derive_globals:
            out_fp.write("\nexport { characters, phdCandidates, postdocCandidates, coPICandidates };\n")
        else:
            out_fp.write("\nexport { characters };\n")
    else:
        out_fp.write("\n")

def emit_grouped(rows, header, out_fp, esm: bool):
    pis, phds, postdocs, copis = [], [], [], []
    for row in rows:
        t = str(row.get("type", "")).strip().lower()
        if t == "phd":
            phds.append(row)
        elif t == "postdoc":
            postdocs.append(row)
        elif t == "copi":
            copis.append(row)
        else:
            pis.append(row)

    out_fp.write("// Generated by csv_to_characters_js.py (grouped-by-type mode)\n")

    def write_array(name, arr):
        out_fp.write(f"const {name} = [\n")
        for i, r in enumerate(arr):
            out_fp.write("  " + row_to_js_object(r, header))
            if i < len(arr) - 1:
                out_fp.write(",")
            out_fp.write("\n")
        out_fp.write("];\n\n")

    write_array("characters", pis)
    write_array("phdCandidates", phds)
    write_array("postdocCandidates", postdocs)
    write_array("coPICandidates", copis)

    if esm:
        out_fp.write("export { characters, phdCandidates, postdocCandidates, coPICandidates };\n")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--csv", default="characters_unified.csv", help="Input CSV path")
    ap.add_argument("--out", default="characters.js", help="Output JS path")
    ap.add_argument("--group-by-type", action="store_true", help="Emit arrays grouped by type")
    ap.add_argument("--boolean-keys", default="hired", help="Comma-separated list of boolean column names")
    ap.add_argument("--esm", action="store_true", help="Emit ES module exports")
    ap.add_argument("--derive-globals", action="store_true", help="In single-array mode, also emit phd/postdoc/coPI arrays")
    args = ap.parse_args()

    boolean_keys = set([k.strip() for k in args.boolean_keys.split(",") if k.strip()])

    with open(args.csv, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        header = reader.fieldnames or []
        rows = [{k: coerce_value(k, v, boolean_keys) for k, v in row.items()} for row in reader]

    with open(args.out, "w", encoding="utf-8", newline="\n") as out_fp:
        if args.group_by_type:
            emit_grouped(rows, header, out_fp, esm=args.esm)
        else:
            emit_single_array(rows, header, out_fp, esm=args.esm, derive_globals=args.derive_globals)

    print(f"Wrote {args.out} with {len(rows)} characters; boolean keys: {sorted(boolean_keys)}; esm={args.esm}; derive_globals={args.derive_globals}")

if __name__ == "__main__":
    main()
